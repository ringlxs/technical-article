## H5-CSS3-JS

##### 1.回流与重绘

- **回流：**元素布局、尺寸的改变，需要重新构建页面

  以下情况会触发回流：

  1. 当元素的尺寸或者位置发生了变化，就需要重新计算渲染树，这就是回流

  2. DOM 元素的几何属性(`width/height/padding/margin/border`)发生变化时会触发回流

  3. DOM 元素移动或增加会触发回流

  4. 读写` offset/scroll/client` 等属性时会触发回流

  5. 调用 `window.getComputedStyle` 会触发回流

- **重绘：**元素外观、颜色的改变，不影响页面布局，只是外观的改变，所依赖的框架不变。跟`vue`里面的具名插槽差不多。

  1. DOM 样式发生了变化，但没有影响 DOM 的几何属性时，会触发重绘，而不会触发回流。重绘由于 DOM 位置信息不需要更新，省去了布局过程，因而性能上优于回流

 **如何减少回流**

1. 使用` class `替代` style`，减少 style 的使用

2. 使用 `resize、scroll` 时进行防抖和节流处理，这两者会直接导致回流

3. 使用` visibility` 替换` display: none`，因为前者只会引起重绘，后者会引发回流

4. 批量修改元素时，可以先让元素脱离文档流，等修改完毕后，再放入文档流

5. 避免触发同步布局事件，我们在获取 `offsetWidth` 这类属性的值时，可以使用变量将查询结果存起来，避免多次查询，每次对 offset/scroll/client 等属性进行查询时都会触发回流

6. 对于复杂动画效果,使用绝对定位让其脱离文档流，复杂的动画效果会频繁地触发回流重绘，我们可以将动画元素设置绝对定位从而脱离文档流避免反复回流重绘。

##### 2.三角形绘制

```css
.sanjiao{
            width: 0px;
            height: 0px;
            border: 50px solid;
            /* transparent:透明 */
            border-color: transparent green transparent transparent;
        }
```

##### 3.Vue中建项目时的runtime-compiler和runtime-only的区别

其实就是main.js入口函数的不同。

runtime-compiler

> template-->ast(语法树)-->render-->vdom-->UI

```js
new Vue({
  el: '#app',
  router,
  components: { App },
  template: '<App/>'
})
```

runtime-only

> render-->vdom-->UI
> 
> 性能更高，代码量更少

```
new Vue({
  router,
  render: h => h(App)
}).$mount('#app')
```

##### 3.前端渲染和后端渲染

- **后端(服务端)渲染阶段**：比如jsp，前台发生网络请求，后台响应数据时是可以写html代码的，也就是把页面渲染后响应到前端。它由后端处理URL和页面之间的映射关系。

- **(前端渲染)前后端分离阶段**：后端只负责提供API接口，不负责任何阶段的内容。前端通过AJAX请求后端接口，把json数据拿到后，可以写html代码渲染到页面。

- **前端路由阶段(SPA页面)**：整个网站只有一个html页面。最开始加载的时候是把所有的静态资源服务器里的东西拿出来，然后通过前端路由来管理。改变url的时候，页面不进行刷新。

##### 4.$router和$route的区别

- $router:拿到的是全局路由里的对象
- $route:拿到的是当前活跃路由里的对象

$router和$route都是往Vue的原型上加的

所有组件都是Vue的原型，所以可以在Vue的原型上面挂载全局组件，方法或者变量

比如：

```
Vue.prototype.$axios=Axios;
```

##### 5.常见图片格式

- jpg(jpeg)
- png
- gif
- webp
- svg

##### 6.link和@import的区别

- link是HTML标签；@import是css中定义的，只能加载样式文件
- link在页面载入时同时加载；@import在页面加载完成后载入
- link支持使用JavaScript修改样式； @import不支持JavaScript改变样式

##### 7.1像素边框问题解决

- ##### viewport + rem+js 方案
  
  在页面初始化时，在头部引入原始默认状态如下：
  
  ```html
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">  
  <meta name="viewport" id="WebViewport" content="initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"> 
  //这句话定义了本页面的viewport的宽度为设备宽度，初始缩放值和最大缩放值都为1，并禁止了用户缩放。
  ```
  
  接下来的任务就是js的动态修改缩放比 以及 实现rem根元素字体大小的设置。
  
  ```js
  var viewport = document.querySelector("meta[name=viewport]")
  if (window.devicePixelRatio == 1) {//1倍屏
      viewport.setAttribute('content', 'width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no')
  } 
  if (window.devicePixelRatio == 2) {//2倍屏
      viewport.setAttribute('content', 'width=device-width, initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no')
  } 
  if (window.devicePixelRatio == 3) {//3倍屏
      viewport.setAttribute('content', 'width=device-width, initial-scale=0.333333333, maximum-scale=0.333333333, minimum-scale=0.333333333, user-scalable=no')
  } 
  
  var docEl = document.documentElement;
  var fontsize = 10 * (docEl.clientWidth / 320) + 'px';
  docEl.style.fontSize = fontsize;
  ```

- ##### box-shadow 方案

```css
-webkit-box-shadow: 0 1px 1px -1px rgba(0, 0, 0, 0.5);
//参数分别表示: 水平阴影位置，垂直阴影位置，模糊距离， 阴影尺寸，阴影颜色，将外部阴影改为内部阴影，后四个可选。
```

- ##### *transform: scale(0.5) 方案 - 推荐: 很灵活*
  
  ```
  设置height: 1px，根据媒体查询结合transform缩放为相应尺寸。也可用::after和::befor设置
  
  div {
      height:1px;
      background:#000;
      -webkit-transform: scaleY(0.5);
      -webkit-transform-origin:0 0;
      overflow: hidden;
  }
  ```

##### 8.标准盒模型和怪异盒模型的区别

- 在标准模式下，一个块的总宽度= width + margin(左右) + padding(左右) + border(左右)

- ```css
  .main1{
      width: 200px;
      height: 200px;
      background-color: aqua;
      box-sizing: content-box; // 标准盒模型
      padding: 10px;
      margin: 10px;
  }
  ```

  

- 在怪异模式下，一个块的总宽度= width + margin(左右)（即width已经包含了padding和border值）

- ```css
  .main2{
      width: 200px;
      height: 200px;
      background-color: red;
      box-sizing: border-box; /* 怪异盒模型 */
      padding: 10px;
      margin: 10px;
  }
  ```

  

##### 9.多行文本溢出

- 使用webkit的css扩展属性——只在-webkit-内核的浏览器中有效

```css
.box{
    width: 200px; 
    overflow: hidden; 
    text-overflow: ellipsis; 

    display: -webkit-box;/* 将元素转换为弹性伸缩盒 */ 
    -webkit-line-clamp: 2;/* 文本内容显示的行数 */ 
    -webkit-box-orient: vertical;/* 弹性伸缩盒子元素排列方式 */ 
}
```

- 使用伪元素模拟溢出显示省略号——兼容性较好(也就是在后面加三点)
  
  ```css
  .box{
      width: 200px; 
      height: 40px;/*是行高的倍数*/ 
      line-height: 20px; 
      overflow: hidden; 
      position: relative; 
  }
  .box::after{ 
      content: "..."; 
      position: absolute; 
      right: 2px; 
      bottom: 0; 
      background: #fff; 
      padding: 0 5px; 
  }
  ```

##### 10.单行文本溢出

```css
overflow: hidden;
text-overflow: ellipsis;
white-space: nowrap;
```

##### 11.BFC

- 本质：块格式化上下文。一个封闭的盒子,是页面上的一个独立的渲染区域，容器中子元素不会影响到外面的元素，反之亦然。

- 怎样生成BFC？
  
  ```
  根元素（html）
  
  浮动元素float: left|right;
  
  绝对定位元素position: absolute|fifixed;
  
  行内块display: inline-block;
  
  overflow: hidden|auto|scroll;
  
  ```

弹性元素（display 值为 flex 或 inline-flex 元素的直接子元素）

  网格元素（display 值为 grid 或 inline-grid 元素的直接子元素）

 BFC解决的问题：

  ①外边距塌陷；②子元素浮动父元素高度塌陷；③防止文字环绕；④两栏 / 三栏自适应



##### 12.跨域

 - 什么是跨域：

  浏览器的对javaScript的一种同源策略的限制，如果协议、域名或者端口有一个不同就是跨域，Ajax请求会失败。请求发出去了，但是没有响应回数据。

- 解决
  
  1.JSONP
  
  利用 <script> 元素的这个开放策略，网页可以得到从其他 来源动态产生的 JSON 数据,但是有缺点只能用get请求。
  
  ```js
  <script src="http://domain/api?param1=a&param2=b&callback=jsonp"></script>
  <script>
  function jsonp(data){
    console.log(data)
  }
  </script>
  ```

​        2.CORS

  实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信

  ```
  //SpringBoot中加一个注解
  @CrossOrigin //解决跨域问题
  ```

  3.服务器端设置http header

##### 13.CSRF攻击

中文名称：跨站请求伪造

> `CSRF` 攻击的原理大致描述如下：有两个网站，其中A网站是真实受信任的网站，而B网站是危险网站。在用户登陆了受信任的A网站是，本地会存储A网站相关的Cookie，并且浏览器也维护这一个Session会话。这时，如果用户在没有登出A网站的情况下访问危险网站B，那么危险网站B就可以模拟发出一个对A网站的请求（跨域请求）对A网站进行操作，而在A网站的角度来看是并不知道请求是由B网站发出来的（Session和Cookie均为A网站的），这时便成功发动一次CSRF 攻击。
> 
>    因而 CSRF 攻击可以简单理解为：攻击者盗用了你的身份，以你的名义发送而已请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......造成的问题包括：个人隐私泄露以及财产安全。

##### 14.html5新标签

```html
<div>
  //头部，页眉
  <header>
    //导航  
    <nav></nav>
  </header>

  //主要区域  
  <main>
     //独立的内容容器
    <article>
       //定义一个区块
      <section>
         //视频 
        <video src="河正宇《小姐》-副本.mp4" preload="auto" muted controls width="800" height="200"></video>
         //音频
         <audio controls preload="auto">
            <source src="守夜人.mp3" type="audio/mp3">
        </audio> 
      </section>

        //定义一个区块
      <section>
          //表单时间
        <input type="date" step="5" min="2020-09-22" max="2025-01-15" name="datetime">
        <input type="week">
        <input type="month">
      </section>
    </article>

     //附加区域 
    <aside>

    </aside>
  </main>

    //脚部，页脚
  <footer>

  </footer>
</div>
```

##### 15.作用域

- 作用域链只向上查找，找到全局window即终止

- 使用 `let/const` 可以将变量声明在块作用域中（放在新的环境中，而不是全局中）

- 静态作用域 & 动态作用域
  
  JavaScript 采用**静态作用域**
  
  **静态** ：因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。
   **动态** ：而与词法作用域相对的是动态作用域，函数的作用域是在函数调用时才决定的。

```javascript
var value = 1  //全局作用域
function foo () {
  console.log(value)
}
function bar () {
  var value = 2 //函数作用域，这里并没有改变外层的值
  foo()
}
bar()  // 输出神马呢？

// 假设：JavaScript采用的是静态作用域。
// 那么函数的作用域在函数定义时就决定了。
// 执行到foo函数，先从foo函数内部查找局部变量value。
// 如果没有就根据书写位置，查找上面一层代码，也就是value = 1。
// 所以结果是1。

// 假设：JavaScript采用的是动态作用域。
// 那么函数的作用域在函数调用时决定。
// 执行到foo函数，先从foo函数内部查找局部变量value。
// 如果没有就从调用函数的作用域，也就是bar函数内部查找value变量，也就是value = 2。
// 所以结果是2。
```

作用域主要有：全局作用域、函数作用域、块作用域、静态作用域、动态作用域

```js
var qqq = 123; //全局作用域
b = 222; // 全局作用域，是 window.b = 222 的简写

function foo () {
  console.log(qqq); //123 函数作用域(静态作用域，声明时已确定，与test()函数内部变量无联系)，作用域从该处往上一级找，上一级作用域为全局作用域
}

function test(){
    yuy = 9090; //全局作用域
    var cheshi = 1234; //函数作用域
    var qqq = '哈哈哈'; //函数作用域
    if(cheshi > 1){
        let zz = 2; //块级作用域
        const xx = 3; //块级作用域
        var yy = 4; //函数作用域,该变量会提升到test()下
    }

    foo();

    console.log(this.b); //this作用域为动态作用域，使用时才会往上找
    console.log(cheshi); //1234
    console.log(qqq); //哈哈哈
    console.log(zz); //报错，not defined
    console.log(xx); //报错，not defined
    console.log(yy); //4
}

test();
console.log(yuy); // 9090
console.log(cheshi); //报错，not defined
```

##### 16.闭包

相当于一个在函数内部的子函数，子函数可以访问外部作用域变量，它本身也可以被外部作用域访问。

闭包的特性：

- 能够读取函数内部的变量
- 能让这些变量的值始终保持在内存中

##### 17.防抖与节流

用一句话总结防抖和节流的区别：防抖是将多次执行变为最后一次执行，节流是将多次执行变为每隔一段时间执行

防抖：搞一个定时器，比如说是1s后执行。如果1s之内还有操作发生，那么它会清空定时时间，重新计时。(比如搜索引擎的搜索功能)

节流：搞一个定时器，比如说是1s内执行一次。如果1s之内还有操作发生，那么我直接忽视你，等我这1s结束之后才鸟你一眼。(比如验证码的发送，间隔60s)

##### 18.浅拷贝深拷贝

不管是深拷贝还是浅拷贝，你都得创建一个新的对象来让它把值复制进去。

浅拷贝：只执行一层，不能进行深层次的复制

- Object.assign

```js
//Object.assign 函数可简单的实现浅拷贝，它是将两个对象的属性叠加后面对象属性会覆盖前面对象同名属性
let user1 = {
    name: '后盾人'
};
let hd = {
    stu: Object.assign({}, user1) // 两对象合一起，相同的取其中一个(后面的覆盖前面的)
};
hd.stu.name = 'hdcms';
console.log(user1.name); //后盾人
```

- 展开语法

```js
//使用展示语法也可以实现浅拷贝
let obj = {
    name: "后盾人"
};
let hd1 = {
    ...obj
};
hd1.name = "hdcms";
console.log("展示语法：");
console.log(hd1.name); //hdcms
console.log(obj.name); //后盾人
```

- for/in

```js
//使用for/in执行对象拷贝
let obj2 = {
    name: "后盾人"
};
let hd2 = {};
for (const key in obj2) {
    console.log(key);
    hd2[key] = obj2[key];
}
hd2.name = "hdcms";
console.log("for-in：");
console.log(hd2); //hdcms
console.log(obj2); //后盾人
```

深拷贝:可深层复制，通过一个函数来递归。如果键的后面还是一个对象或者数组，那么就需要进行深拷贝了

```js
//有数组
let obj4 = {
    name: "后盾人",
    user: {
        name: "hdcms"
    },
    data: []
};

function copy(object) {
    //1.判断传进来的对象是一个数组对象还是一个字面量对象，方便知道创建空对象的类型
    let obj4 = object instanceof Array ? [] : {};
    //2.通过对象迭代的方式来进行深拷贝
    for (const [k, v] of Object.entries(object)) {
        //判断键后面的是不是一个对象，如果是，再调用一次本身(递归)
        //注：{}和[]都属于object对象类型，也就是说数组也是一个对象
        obj4[k] = typeof v == "object" ? copy(v) : v;
    }
    return obj4;
}
let hd4 = copy(obj4);
hd4.data.push("向军");
console.log("1:" + JSON.stringify(hd4, null, 2));
console.log(JSON.stringify(obj4, null, 2));
```

##### 19.宏任务与微任务

任务的执行顺序是同步任务、微任务、宏任务。(事件循环机制)

```js
console.log("后盾人");//同步任务
setTimeout(function() {
  console.log("定时器");//异步宏任务
}, 0);
Promise.resolve()//同步任务
  .then(function() {
    console.log("promise1");//异步微任务
  })
  .then(function() {
    console.log("promise2");//异步微任务
  });
console.log("houdunren.com");//同步任务

#输出结果为
后盾人
houdunren.com
promise1
promise2
定时器
```

```js
console.log('1');

setTimeout(function() {
    console.log('2');
    process.nextTick(function() {
        console.log('3');
    })
    new Promise(function(resolve) {
        console.log('4');
        resolve();
    }).then(function() {
        console.log('5')
    })
})
process.nextTick(function() { // 在事件循环的下一次迭代中调用回调函数
    console.log('6');
})
new Promise(function(resolve) {
    console.log('7');
    resolve();
}).then(function() {
    console.log('8')
})

setTimeout(function() {
    console.log('9');
    process.nextTick(function() {
        console.log('10');
    })
    new Promise(function(resolve) {
        console.log('11');
        resolve();
    }).then(function() {
        console.log('12')
    })
})

// 以上代码执行结果为
整个代码，一共经过了3次事件循环，完整的输出为1,7,6,8,2,4,3,5,9,11,10,12。
```

```js
async function async1() {
    console.log('async1 start'); // 同2
    await async2(); // await之前的为同步任务，立即执行，然后执行async2()函数，输出 'async2'，将 ‘console.log('async1 end')’分配到microtask（微任务）队列中
    console.log('async1 end');// 异微6
}

async function async2() {
    console.log('async2');// 同3
}

console.log('script start'); // 同1

setTimeout(function() {
    console.log('setTimeout');// 异宏8
}, 0)

async1();

new Promise(function(resolve) {
    console.log('promise1'); // 同4
    resolve();
}).then(function() {
    console.log('promise2');// 异微7
});

console.log('script end');// 同5
/*
    script start
    async1 start
    async2
    promise1
    script end
    async1 end
    promise2
    setTimeout
*/
```

```js
// 从第一行代码直到（并包括）第一个 await 表达式（如果有的话）都是同步运行的，
async function async1() {
    console.log('async1 start'); // 同2
    await  console.log(async2()); // 同3，等待异步返回
    // 以下都加入到微任务队列里
    await  a();// 异一层6
    await  c();// 异二层8
    console.log('async1 end');// 异微三层9
}

function a(){
    console.log("8");
}

async function c(){
    await console.log("99");
}

async function async2() {
  new Promise(resolve => {
    setTimeout(() => {
      console.log('async2');// 异宏11
    }, 2000);
  });
}

console.log('script start');// 同1

async1();

setTimeout(function() {
    console.log('setTimeout');// 异宏10
}, 0)

new Promise(function(resolve) {
    console.log('promise1');// 同4
    resolve();
}).then(function() {
    console.log('promise2');// 异一层7
});

console.log('script end');// 同5

/*
script start
async1 start
Promise {<fulfilled>: undefined} // 这里就是async1()后面的async2()方法开始执行
promise1
script end
8
promise2
99
async1 end
setTimeout
async2 // async2()最后才出结果
*/
```

##### 20.原型与继承

**原型：**

每个对象都有一个原型`prototype`对象，通过函数创建的对象也将拥有这个原型对象。原型是**一个指向对象的指针**。

当我们用`obj.xxx`访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到`Object.prototype`对象，最后，如果还没有找到，就只能返回`undefined`。

**原型链：**

```js
例如，创建一个Array对象：

var arr = [1, 2, 3];

其原型链是：

arr ----> Array.prototype ----> Object.prototype ----> null

Array.prototype定义了indexOf()、shift()等方法，因此你可以在所有的Array对象上直接调用这些方法。
```

**继承：**

当对象中没使用的属性时，JS 会从原型上获取这就是继承在 JavaScript 中的实现。

因为有时根据得到的对象获取构造函数，然后再创建新对象所以需要保证构造函数存在，但如果直接设置了 `Admin.prototype` 属性会造成`constructor`丢失，所以需要再次设置`constructor`值。

```js
function User() {}
function Admin() {}

/*Admin原型对象继承User原型对象，你不能够直接这样：Admin.prototype = User.prototype
这不是继承，这只是把原型对象改变了而已*/
Admin.prototype = Object.create(User.prototype);
Admin.prototype.role = function() {};

let xj = new Admin();
console.log(xj.constructor); //constructor丢失，返回User构造函数

Admin.prototype.constructor = Admin;

let hd = new Admin();
console.log(hd.constructor); //正确返回Admin构造函数
```

##### 21.Promise异步

- promise 是一个拥有 `then` 方法的对象或函数

- 一个 `promise` 必须有一个 `then` 方法用于处理状态改变

**1.三种状态**：`resolve`(指已经解决)、`reject`(指拒绝处理)、`pending`(指等待)

```js
//等待
console.log(
  new Promise((resolve, reject) => {
      /*resolve,和reject都没有使用，所以为等待状态*/
  });
); //Promise {<pending>}

//成功
console.log(
  new Promise((resolve, reject) => {
    resolve("fulfilled");
  })
); //Promise {<resolved>: "fulfilled"}

//失败
console.log(
  new Promise((resolve, reject) => {
    reject("rejected");
  })
); //Promise {<rejected>: "rejected"}
```

**2.then**

`then` 是对上个promise 的`rejected` 的处理，每个 `then` 会是一个新的promise，默认传递 `fulfilled`状态

```js
new Promise((resolve, reject) => {
  reject();
})
.then(
  resolve => console.log("fulfilled"),
  reject => console.log("rejected")
)
.then(
  resolve => console.log("fulfilled"),
  reject => console.log("rejected")
)
.then(
  resolve => console.log("fulfilled"),
  reject => console.log("rejected")
);

# 执行结果如下
  ejected
  fulfilled
  fulfilled
```

**3.catch**

`catch` 可以捕获之前所有 `promise` 的错误，所以建议将 `catch` 放在最后。下例中 `catch` 也可以捕获到了第一个 `then` 返回 的 `promise` 的错误。

```js
new Promise((resolve, reject) => {
  resolve();
})
.then(() => {
  return new Promise((resolve, reject) => {
    reject(".then ");
  });
})
.then(() => {})
.catch(msg => {
  console.log(msg);
});
```

**4.finally**

无论状态是`resolve` 或 `reject` 都会执行此动作，`finally` 与状态无关。

```js
const promise = new Promise((resolve, reject) => {
  reject("hdcms");
})
.then(msg => {
  console.log("resolve");
})
.catch(msg => {
  console.log("reject");
})
.finally(() => {
  console.log("resolve/reject状态都会执行");
});
```

**5. async/await**

使用 `async/await` 是promise 的语法糖，可以让编写 promise 更清晰易懂，也是推荐编写promise 的方式。

- `async/await` 本质还是promise，只是更简洁的语法糖书写
- `async/await`  使用更清晰的promise来替换 promise.then/catch 的方式

async:

下面在 `hd` 函数前加上async，函数将返回promise，我们就可以像使用标准Promise一样使用了

```js
async function hd() {
  return "houdunren.com";
}
console.log(hd());
hd().then(value => {
  console.log(value);
});
```

await:

使用 `await` 关键词后会等待promise 结束后执行

- `await` 后面一般是promise，如果不是直接返回
- `await` 必须放在 async 定义的函数中使用
- `await` 用于替代 `then` 使编码更优雅

下例会在 await 这行暂停执行，直到等待 promise 返回结果后才继执行。

```js
async function hd() {
  const promise = new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve("houdunren.com");
    }, 2000);
  });
  let result = await promise;
  console.log(result);
}
hd()
```

错误处理：

catch

```js
async function get(name) {
  return await ajax(`http://localhost:8888/php/user.php?name=${name}`);
}

get("向军小哥").catch(error => {
  alert("用户不存在");
});
```

如果`promise` 被拒绝将抛出异常，可以使用 `try...catch` 处理错误

```js
async function get(name) {
  try {
    let user = await ajax(
      `http://localhost:8888/php/user.php?name=${name}`
    );
    console.log(user);
  } catch (error) {
    alert("用户不存在");
  }
}
get("向军老师");
```

##### 22. js_DOM节点增删改查

**创建节点**：

```html
<div id="app2">这是spp2</div>
<script>
    // 获取已存在节点
    let app2 = document.querySelector('#app2')
    // 创建节点
    let span2 = document.createElement('span')
    // 节点内容
    span2.innerHTML = 'houdunren你好'
    // 将创建的节点插入文档流
    app2.append(span2);//最后插入到#app2里面的最后
</script>
```

**查**：节点获取

```html
<div id="app">
    <div class="houdunren" data="hd">houdunren.com</div>
    <div class="houdunwang">houdunwang.com</div>
    <div class="xiangjun"><!-- 向军大叔 --></div>
</div>

<script>
    const app = document.querySelector(`#app`)
    console.log(app.children) //所有子元素
    console.log(app.firstElementChild) //第一个子元素 div.houdunren
    console.log(app.lastElementChild) //最后一个子元素 div.xiangjun

    const houdunwang = document.querySelector('.houdunwang')
    console.log(houdunwang.parentElement) //父元素 div#app

    console.log(houdunwang.previousElementSibling) //上一个兄弟元素 div.houdunren
    console.log(houdunwang.nextElementSibling) //下一个兄弟元素 div.xiangjun
</script>
```

**改**：

改属性：

直接设置元素的属性

```html
<div id="app">
  <div data="hd">houdunren.com</div>
  <div>houdunwang.com</div>
</div>
<script>
  const app = document.querySelector(`#app`)
  app.className = 'houdunren呀'
</script>
```

通过`setAttribute`设置属性

```html
<div id="app">
  <div data="hd">houdunren.com</div>
  <div>houdunwang.com</div>
</div>
<script>
  const app = document.querySelector(`#app`)
  app.setAttribute('className', "houdunren呀");
</script>
```

改内容`innerHTML`：

```html
<div id="app5">
    houdunren.com
</div>
<script>
    let app5 = document.querySelector('#app5')
    let h5 = document.createElement('h4')
    h5.append('houdunwang.com改内容5');
    app5.innerHTML=h5.innerHTML;
</script>
```

改内容和标签`replaceWith`，把节点也换了

```html
<div id="app4">
    houdunren.com
</div>
<script>
    let app4 = document.querySelector('#app4')
    let h4 = document.createElement('h4')
    h4.append('houdunwang.com改内容4');
    app4.replaceWith(h4);
</script>
```

增：

```html
<div id="app6">
    这里是元素
</div>
<script>
    let app6 = document.querySelector('#app6')

    //插入字符串或节点,不能够直接解析html标签,所以需要创建
    let afterDom = "<h5>"
    afterDom += "-houdunwang.com6元素本身后面</h5>"

    let beforep=document.createElement('p');
    beforep.className='beforep';
    beforep.innerHTML='-houdunwang.com6元素本身前面';  

    app6.before(beforep);
    app6.prepend('-houdunwang.com6元素内部前面')
    //用古老的方式(appendChild)只能插入节点,不能够直接插入字符串
    app6.append('-houdunwang.com6元素内部后面')
    app6.after(afterDom)

    //会解析html标签
    let before6='本身'
    let beforebegin6='<h4>'+
        '元素'+before6+'前面'+
        '</h4>'

    let abgin='内部'
    let afterbegin6=`
                     <div>
                       <h4>
                         元素${abgin}前面
                       </h4>        
                     </div>
                    `
    let afterend6='<div>'
    afterend6+='<h4>元素本身后面</h4>'
    afterend6+='</div>'
    app6.insertAdjacentHTML('beforebegin', beforebegin6)//元素本身前面
    app6.insertAdjacentHTML('afterbegin', afterbegin6)//元素内部前面
    app6.insertAdjacentHTML('beforeend', '<h4>元素内部后面</h4>')
    app6.insertAdjacentHTML('afterend', afterend6)//元素本身后面
</script>
```

![image-20211101212337599](C:%5CUsers%5C20837%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211101212337599.png)

**删：**

```html
<div id="app7">
    <p>删除</p>
    <p>这是药删除的节点1</p>
    <span>这是药删除的节点2</span>
</div>
<script>
    //直接删
    let app7 = document.querySelector('#app7>p:nth-of-type(2)')
    app7.remove();//第二个p已经删除了

    //先获取父元素,再获取本身元素,根据父元素来删
    let Fuapp7=document.querySelector('#app7');
    let chapp7=document.querySelector('#app7>span')
    Fuapp7.removeChild(chapp7);//span也已经删除
</script>
```

**复制，克隆**

```html
<h2>复制</h2>
<div id="app8">复制,克隆1</div>
<script>
    let app8 = document.querySelector('#app8')
    let newApp8 = app8.cloneNode(true)
    document.body.appendChild(newApp8)
</script>
```

##### 23.HTTP请求

- GET：用于获取数据，GET是在URL上传递数据（网址后面的东西），存储量较少，安全系数比较低。

- POST：用于上传数据，POST安全性一般比（GET好一些），容量几乎是无限（多用于表单）。

##### 24.ajax&&axios

原生ajax,四个步骤：

> 1. -创建Ajax
> 2. -连接服务器
> 3. -发送请求
> 4. -接收返回值

```js
// 1.创建对象 XMLHttpRequest()
var xhr = new XMLHttpRequest();
// 2.连接服务器，配置参数，（请求方式，请求地址，同异步）
xhr.open('get', 'abc.txt', true);//async 类型为 Boolean 值, 设置 true 时代码该请求使用异步， 设置 false 时代码该请求使用同步。
// 3.发送数据
xhr.send();  // 如果是读取本地文件，可以设置为空
// 4.监听事件，接收返回的数据，改变页面
xhr.onreadystatechange = function () {// 
    // 同时满步骤4和状态码为200时
    if (xhr.readyState === 4 && xhr.status === 200) {
        console.log('请求成功：', xhr.responseText);
        // 这里可以改变页面内容了
    }
}
```

jQuery-Ajax

```js
// jQuery：请求地址，请求方式，发送的数据，接收返回值
$.ajax({
    url: 'abc111.txt',  // 请求地址
    type: 'get', // 请求方式（类型）
    data: '', // 要发送的数据
    success(data) { // 请求成功时执行的函数，形参就是获取的数据
        console.log('请求成功：', data);
        // 改变页面操作可以写在这里
    },
    error(err) { // 请求出错时执行的函数，形参是错误信息
        console.log('请求出错：', err);
    }
});
```

```js
$.ajax({
    url: '', // 请求的地址
    cache: 布尔值, // 是否缓存，get请求如果url没有发生变化，则会走缓存
    type: '', // 请求的方式（get/post），默认为get
    timeout: '', // 设置请求超时时间，单位毫秒
    data: '', // 发送到后端的数据
    dataType: '', // 预期服务器返回的数据类型，有xml, html, script, json, jsonp, text
    success: function(data) {}, // 成功的回调
    error: function(err) {}, // 失败的回调
    complete: function() {}, // 请求完成后调用的函数，请求成功或失败均调用
    global: true // 是否触发全局的ajax事件，默认为true
});
```

axios

```js
axios({
    method: 'post',  // 请求方式get/post 
    url: 'api',  //后台地址
    data: obj,  // 传递的参数，这里必须使用URLSearchParams或FormData类型
    responseType: 'json'  //响应数据类型  相当于Ajax中的dataType，默认是json
}).then(response => { //请求成功
    let res = response.data;//获取响应数据
    console.log(res);
}).catch(error => { //请求失败
    console.log(error);
});
```

```js
//get请求模板
axios.get('url?id=12345').then(response => {
     console.log(response.data);
 }).catch(error => {
     console.log(error)
});

或者
axios.get('url',{
    params:{
        id:12345
    }
}).then(response => {
     console.log(response.data);
 }).catch(error => {
     console.log(error)
});
```

```js
//post请求模板
axios.post('url', "name=迪丽热巴&age=23").then(response => {
     console.log(response.data);
 }).catch(error => {
     console.log(err)
});

或者
axios.post('url',{
    name:'迪丽热巴',
    age:23
}).then(response => {
     console.log(response.data);
 }).catch(error => {
     console.log(err)
});
```

##### 25.数组

```js
/* 展开语法 */
let a1=[1,2,3,'a','b','c'];
let b1=[...a1,'哈哈哈','真好'];
console.log("展开语法:"+b1);//展开语法:1,2,3,a,b,c,哈哈哈,真好

/* 解构赋值 */
let [a2,b2]=['赋值给a2','赋值给b2'];
console.log(`数组解构：${a2}。${b2}`);//数组解构：赋值给a2。赋值给b2
let {a22,b22}={'a22':'赋值给a22','b22':'赋值给b22'};
console.log(`对象解构：${a22}。${b22}`);//对象解构：赋值给a22。赋值给b22


/* 剩余解构 */
let [a3,...b3]=['赋值给a3','b3的','还是b3的','还是b3的'];
console.log(`剩余解构：${a3}。${b3}`);//剩余解构：赋值给a3。b3的,还是b3的,还是b3的

/* 增删改查、排序、过滤、迭代 */

//数组后面压入:push
let a4=[1,2,3];
a4.push('压入1','压入2');
console.log(`数组后面压入:${a4}`);//数组后面压入:1,2,3,压入1,压入2

//数组后面弹出:pop
let a5=[1,2,3];
a5.pop()
console.log(`数组后面弹出:${a5}`);//数组后面弹出:1,2

//数组前面压入:unshift
let a6=[1,2,3];
a6.unshift('压入1','压入2');
console.log(`数组前面压入:${a6}`);//数组前面压入:压入1,压入2,1,2,3

//数组前面弹出:shift
let a7=[1,2,3];
a7.shift();
console.log(`数组前面弹出:${a7}`);//数组前面弹出:2,3

//数组复制:slice
let a8=[1,2,3];
let b8=a8.slice();//全部复制
let c8=a8.slice(1,2);//左闭右开[1,2)，不传第二个参数时默认复制到最后
console.log(`数组复制a8:${a8}。b8:${b8}`);//数组复制a8:1,2,3。b8:1,2,3
console.log(`数组按需复制:${c8}`);//数组按需复制:2

//数组按需增删改：splice(从哪开始删除，删除数量，添加)
let a9=[1,2,3,4,5];
a9.splice(1,2);//从下标为1开始，往后删除2个
console.log(`splice删除：${a9}`);//splice删除：1,4,5

let a10=[1,2,3,4,5];
a10.splice(1,2,'好','靓仔','哈好好');//不管后面有多少个，都是要增进去的
console.log(`splice先删后增:${a10}`);//splice先删后增:1,好,靓仔,哈好好,4,5

//清空数组
let a11=[1,2,3];
a11=[];//清空
console.log("清空："+a11);

//合并拆分
//合并：通过什么合并
let a12=[1,'a','还好',2];
//合并后从一个object对象类型变成了一个string字符类型
console.log(`合并:${a12.join('')}`);//合并:1a还好2
console.log(`合并:${a12.join('-')}`);//合并:1-a-还好-2
//拆分：通过什么拆开
let a13="123,abc";
console.log(`拆分：${a13.split(',')}`);//拆分：123,abc,1ac,3cb
console.log(`拆分：${a13.split('c')}`);//拆分：123,ab,,1a,,3,b
//先拆再反转后合并
let a14="123abc";
console.log(`先拆再反转后合并:${a14.split('').reverse().join('-')}`);//先拆再反转后合并:c-b-a-3-2-1

//查
let a15=[1,2,3,'a','b','c'];

//返回元素的下标，查不到返回-1 
//从前往后查：indexOf,查找元素出现的位置(就算元素重复，但我查到第一个之后就把它的下标返回，常用于过滤)
console.log("indexOf从前往后查:"+a15.indexOf(3));//indexOf从前往后查:2
console.log("indexOf从前往后查:"+a15.indexOf('b'));//indexOf从前往后查:4
console.log("indexOf从前往后查(第二个参数指定从哪里开始查):"+a15.indexOf('b',3));//indexOf从前往后查(第二个参数指定从哪里开始查):4
console.log("indexOf从前往后查(查不到):"+a15.indexOf(5));//indexOf从前往后查(查不到):-1
//从后往前查：lastIndexOf
console.log("lastIndexOf从后往前查:"+a15.lastIndexOf(3));//lastIndexOf从后往前查:2
console.log("lastIndexOf从后往前查:"+a15.lastIndexOf('b'));//lastIndexOf从后往前查:4
console.log("lastIndexOf从后往前查(第二个参数指定从哪里开始查):"+a15.lastIndexOf('b',3));//lastIndexOf从后往前查(第二个参数指定从哪里开始查):-1
console.log("lastIndexOf从后往前查(查不到):"+a15.lastIndexOf(5));//lastIndexOf从后往前查(查不到):-1

//返回布尔值includes，不能查找引用类型比如：对象、数组
console.log("includes返回布尔值："+a15.includes('a'));//includes返回布尔值：true
const a16 = [{ name: "李四" }, { name: "张三" }, { name: "qq" }];
const includes = a16.includes({ name: "qq" });
console.log(includes);//false

//返回具体值：find，可以方便的查找引用类型
/*
find()方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，
直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。

findIndex()方法的用法与find()方法非常类似，返回第一个符合条件的数组成员的位置，
如果所有成员都不符合条件，则返回-1。
*/
const a17 = [{ name: "李四" }, { name: "张三" }, { name: "qq" }];
const b17=[1,2,5,6,-2,-3];
const find1 = a17.find(a17 => (a17.name == "张三"));//查找数组对象中名字为"张三"的对象
const find2 = b17.find(b17=> b17 < 0);//查找数组中小于0的第一个值
const find3 = b17.findIndex(b17=> b17 < 0);//查找数组中小于0的第一个值的下标
console.log(find1);//{name: '张三'}
console.log(find2);//-2
console.log(find3);//4

//排序sort
let a18 = [1,4,3,6,8];
let lessons = [
{ title: "媒体查询响应式布局", click: 78 },
{ title: "FLEX 弹性盒模型", click: 12 },
{ title: "MYSQL多表查询随意操作", click: 99 }
];
console.log("默认从小到大："+a18.sort());//默认从小到大：1,3,4,6,8
//参数一与参数二比较，返回 正数:降序。负数：升序
console.log("正数降序："+a18.sort((a,b) => b-a ));//降序：8,6,4,3,1
console.log("负数升序："+a18.sort((a,b) => a-b ));//升序：1,3,4,6,8
console.log(lessons.sort((a,b) => a.click - b.click ));

//遍历
let a19 = [
{title: '媒体查询响应式布局',category: 'css'},
{title: 'FLEX 弹性盒模型',category: 'css'},
{title: 'MYSQL多表查询随意操作',category: 'mysql'}
];
//for循环
let b19=[];
for (let i = 0; i < a19.length; i++) {
b19[i]=a19[i].title;//下标也对应起来，相当于浅拷贝了
}
console.log("for循环：");
console.log(b19);//['媒体查询响应式布局', 'FLEX 弹性盒模型', 'MYSQL多表查询随意操作']    

//forEach:forEach使函数作用在每个数组元素上，但是没有返回值。
console.log("forEach：");
a19.forEach((item,index,array)=>{//(元素，下标,数组整体本身)
console.log(item);
/*
{title: '媒体查询响应式布局', category: 'css'}
{title: 'FLEX 弹性盒模型', category: 'css'}
{title: 'MYSQL多表查询随意操作', category: 'mysql'}
*/
})

//for...in...
console.log("for...in...：");
for(const key in a19){//key为下标索引
console.log(key+':'+a19[key].title);
/*
0:媒体查询响应式布局
1:FLEX 弹性盒模型
2:MYSQL多表查询随意操作
*/
}

//for...of...
console.log("for...of...:");
for(const item of a19){//item为元素值
console.log(item);
/*
{title: '媒体查询响应式布局', category: 'css'}
{title: 'FLEX 弹性盒模型', category: 'css'}
{title: 'MYSQL多表查询随意操作', category: 'mysql'}
*/
}


//迭代,通过遍历辅助迭代的执行
//获取索引：keys
console.log("迭代下标索引keys:");
const a20 = ["a", "b", "c"];
for (const key of a20.keys()) {
console.log(key);//0 1 2
}
//获取值：values
console.log("迭代值values:");
for(const item of a20.values()){//其实用了for..of迭不迭代item都是值，values()就没有存在的必要了
console.log(item);//a b c
}
//获取键和值：entries
console.log("迭代键值对entries:");
for(const [k,v] of a20.entries()){
console.log(k,v);
/*
0 'a'
1 'b'
2 'c'
*/
}

//过滤
//filter
/*
filter 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或 等价于 true 的值 的元素创建一个新数组。
那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中。
filter 不会改变原数组。
*/
console.log("过滤器：");
let a21=[1,5,2,5,2,8,12,16];
let b21=a21.filter(item=>item>10);// 为true的就把它拿出来
let c21=a21.filter((item, index, array)=>{
/*
indexOf用于查找元素出现的位置，为0 1 2 1 2 5 6 7
index为元素下标，为0 1 2 3 4 5 6 7
*/
return array.indexOf(item) === index;//数组去重
});
console.log(b21);//[12, 16]
console.log(c21);//[1, 5, 2, 8, 12, 16]
```

##### 26.http和https

http:

- 超文本传输协议，传输数据以明文形式显示，端口为80

- 无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作。

- 无连接：每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。报文从运用层传送到运输层，运输层通过TCP三次握手和服务器建立连接，四次挥手释放连接。

- ###### 针对无状态的一些解决策略：
  
  1. 通过`Cookie/Session`技术
  2. HTTP/1.1持久连接（HTTP keep-alive）方法，只要任意一端没有明确提出断开连接，则保持TCP连接状态，在请求首部字段中的`Connection: keep-alive`即为表明使用了持久连接

<img src="C:%5CUsers%5C20837%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211105161917931.png" alt="image-20211105161917931" style="zoom:50%;" />

https:

- 超文本传输加密协议，端口为433，身披SSL/TLS外壳的HTTP。经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。
- 内容加密：采用混合加密技术，中间者无法直接查看明文内容
- 验证身份：通过证书认证客户端访问的是自己的服务器
- 保护数据完整性：防止传输的内容被中间人冒充或者篡改

##### 27.js_BOM

> `window` : BOM中最顶层对象
> 
>  `location`： 地址栏对象
> 
>  `history`：历史记录对象
> 
>  `navigator`： 浏览器信息对象
> 
>  `document` ： 文档对象
> 
>  `screen` ：屏幕对象
> 
>  `frames` :框架集

**(1)window对象**

```js
//浏览器的事件 ---window可以省略不写

//加载时间.表示当前页面所有内容都加载完成再加载这个函数
window.onload = function(){}

//当浏览器的尺寸发生改变时回触发
onresize = function(){}

//当看看去的滚动条发生滚动的时候会触发
onscroll = function(){}
```

**(2)location对象**

```js
window.location.href;  //获取当前地址栏的地址
window.location.href = “http://www.baidu.com”; // 设置当前地址栏的地址
window.location.reload();  //刷新
window.location.reload(true);  //强制刷新
```

**(3)history对象**

```js
window.history.forword(); //上一步
window.history.back();  //下一步
window.history.go(0);  //接收参数 0   表示刷新当前页面
window.history.go(2); //接收正整数  表示前进2个页面
window.history.go(-2); //接收负整数  表示后退2个页面
```

**(4)navigator对象**

```js
console.log(navigator);

/*
    appName---浏览器名称 NetScape
    appCodeName---浏览器内核
    appVersion---浏览器版本
    userAgent---浏览器的整体信息
*/
```

**(5)document对象**

```js
浏览器当中也是有DOM的，不过它代表的是全局

//结构操作:
document.documentElenment---html标签
document.body---body标签
document.head---head标签
document.title---titile标签

//滚动的距离
document.documnetElement.scrollTop-------有文档声明时使用
document.body.scrollTop------没有文档声明使用-----兼容写法使用短路运算
```

**(6)screen对象**

```js
//除了任务栏外的高度-宽度
screen.availHeight 
screen.availWidth
//包含了任务栏的高度-高度
screen.height 
screen.width
```

**(7)三大家族**

- offset家族
  
  >  offsetWidth / offsetHeight ： 获取的宽高包含：边框 + 内边距 + 元素宽高
  >  offsetParent  ： 获取元素的第一个定位祖先元素 ，如果没有定位的则获取到的是body
  >  offsetLeft /offsetTop ：获取元素到第一个定位元素的偏移量，如果没有定位的则获取到的是到body的偏移量

- client家族
  
  >  clientWidth / clientHeight ： 获取的宽高包含内边距 + 元素宽高
  >  clientLeft /clientHeight ： 获取 元素的 左边框 或者 顶部边框

- scroll家族
  
  >  scrollWidth / scrollHeight ：当内容没超出元素范围时 获取的是 内边框 + 元素宽高
  >  当内容超出元素范围时  获取的是 内边框 + 元素宽高+超出的宽度
  >  scrollTop / scrollLeft ：Top获取的是内容超出顶部内边距的距离 Left获取的是内容超出左边内边距的距离

##### 28.本地存储与会话

**cookie**：

存储在本地，存在浏览器缓存中，有指定时间 ，Cookie在计算机中是个存储在浏览器目录中的文本文件

**localStorage**:

存储在本地，需要手动删除才会消失，不主动清除一直存在

```js
// 本地存储
localStorage.setItem('name','xzp');
//对象需要使用 JSON.stringify()
localStorage.setItem('goto',JSON.stringify({age:18}));
//获取数据
let name = localStorage.getItem('name');
//对象需要使用 JSON.parse()
let obj = JSON.parse(localStorage.getItem('goto'));
```

**sessionStorage**:

存储在本地，关闭浏览器和标签页就会消失

```js
// 本地存储
sessionStorage.setItem('name','xzp');
//对象需要使用 JSON.stringify()
sessionStorage.setItem('goto',JSON.stringify({age:18}));
//获取数据
let name = sessionStorage.getItem('name');
//对象需要使用 JSON.parse()
let obj = JSON.parse(sessionStorage.getItem('goto'));
```

**session**:

存储在服务器上

**token:**

token是用户身份的验证方式，我们通常叫它：令牌

**sessionStorage 、localStorage和cookie之间的区别**：

共同点：都是保存在浏览器端，且都遵循同源策略。

不同点：

1. localStorage 是持久化的，存储在其中的数据是永远不会过期的，需要手动删除。一般为5MB左右。
2. sessionStorage是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。一般为5MB左右。
3. cookie一般由服务器生成，可设置失效时间，如果在浏览器端生成cookie，默认关闭浏览器后失效。cookie大约在4k左右。

##### 29.基本数据类型和判断

> **基本类型**：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）
> 
> **引用类型**：对象(Object)、数组(Array)、函数(Function)

```js
var a = "iamstring";
var b = 222;
var c= [1,2,3];

1.最常见的判断方法：typeof
alert(typeof a)  ------------> string
alert(typeof b)  ------------> number
alert(typeof c)  ------------> object

2.判断已知对象类型的方法： instanceof
alert(c instanceof Array) ---------------> true
```

##### 30.事件委托

把原本需要绑定在子元素的响应事件委托给父元素，让父元素担当事件监听的职务。事件委托的原理是DOM元素的事件冒泡。

##### 31.怎么阻止默认动作？

```js
var $a = document.getElementsByTagName("a")[0];
$a.onclick = function(e){
alert("跳转动作被我阻止了")
e.preventDefault();
//return false;//也可以
}
默认事件没有了。
```

##### 32.如何阻止事件冒泡

w3c 的方法是 `e.stopPropagation()`，IE 则是使用 `e.cancelBubble = true`

##### 33.页面加载，url到得到html的详细过程

- 从输入url到得到html的详细过程
  
  <img src="C:%5CUsers%5C20837%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211116124807246.png" alt="image-20211116124807246" style="zoom: 50%;" />
  
  <img src="C:%5CUsers%5C20837%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211116125137968.png" alt="image-20211116125137968" style="zoom: 50%;" />

- window.onload和DOMContentLoaded的区别

##### 34.常见状态码

- 200：成功态
- 301：永久重定向
- 302：临时重定向
- 403：服务器拒绝该次访问
- 404：路径有错
- 500：服务器出错

##### 35.js和jQuery对象的转换

需要强调的是jquery对象是数组对象，基于此原理,可以进行jquery对象与js对象之间的相互转换。

**js转jQuery:**

```js
//只需要加上$()
var domObj = document.getElementById("exampleId");
var jqueryObj = $(domObj);
```

**jQuery转js:**

```js
//根据索引
var $jqueryObj =$("#exampleId); //此时该对象为一个jquery对象 
var domObj = $jqueryObj[0];
```

##### 36. var变量提升

使用 `var` 定义的代码，声明会被提升到前面，赋值还在原位置。仅仅是用var声明的，用let\const的不会。

```js
console.log(a); //undefined
var a = 1;
console.log(a);  //1

//以上代码解析器执行过程如下
var a;
console.log(a); //undefined
a = 1;
console.log(a); //1
```

##### 37. 字符串

1.截取

```text
let hd = 'houdunren.com';
```

```js
1. substring
(1)从左往右截取（左闭右开）(2)第二个参数为截取的结束位置 (3)小的做为起始位置 (4)负数转为0
console.log(hd.substring(3)); //dunren.com
console.log(hd.substring(3, 6)); //dun 
console.log(hd.substring(3, 0)); //hou 较小的做为起始位置
console.log(hd.substring(3, -9)); //hou 负数转为0

2. slice
(1)正数从左往右截取（左闭右开）(2)第二个参数为截取的结束位置 (3)小的做为起始位置 (4)负数从后算
console.log(hd.slice(3)); //dunren.com
console.log(hd.slice(3, 6)); //dun
console.log(hd.slice(3, -1)); //dunren.co 第二个为负数表示从后面计算的字符位置
console.log(hd.slice(-2));//om 从末尾取(从后面计算，计算到该位置后还是往右截取)

3. substr
(1)正数从左往右截取 (2)第二个参数为截取的字符数量 (4)负数从后算
console.log(hd.substr(3)); //dunren.com
console.log(hd.substr(3, 6)); //dunren
console.log(hd.substr(-3, 2)); //co 从后面第三个开始往右取两个
```

##### 38. 数组去重

```js
const aa = [34,11,11,22,33,22,'46','we','we','hog'];

// 方法一
let bb = aa.filter((item,index,arr)=>{
    return arr.indexOf(item) === index;
})
console.log(bb) // [34, 11, 22, 33, '46', 'we', 'hog']

// 方法二
let cc = Array.from(new Set(aa));
console.log(cc); // [34, 11, 22, 33, '46', 'we', 'hog']

// 方法三
let dd = aa.reduce((calArr,item)=>{
    calArr.includes(item) ? '' : calArr.push(item); 
    return calArr;
},[])
console.log(dd) // [34, 11, 22, 33, '46', 'we', 'hog']

// 方法四
let ee = [...new Set(aa)];
console.log(ee) // [34, 11, 22, 33, '46', 'we', 'hog']

```

##### 39.变量/垃圾回收机制

**下列代码存在几个变量没有被回收？**

```js
答案：3

var i = 1;   // 全局变量不会被回收
var i = 2;   // 这里重复声明变量i,因此var声明被忽略，只是把i赋值为2
var add = function() {  // 全局变量不会被回收
    var i = 0;  // 局部变量
    return function() {
        i++;
        console.log(i); // 被另一个作用域引用导致不会被回收
    }
}();
add();
```

**1.变量回收原则**

1. 全局变量**不会被回收**。
2. 局部变量会**被回收**，也就是函数一旦运行完以后，函数内部的东西都会被销毁。
3. 只要被另外一个作用域所引用就**不会被回收**（闭包）



**2.JS的垃圾回收机制**

（1）标记清除

JS中最常见的垃圾回收方式是**标记清除**
标记清除的概念也好理解，**从根部出发看是否能达到某个对象，如果能达到则认定这个对象还被需要，如果无法达到，则释放它**，这个过程大致分为三步：

- 垃圾回收器创建roots列表，roots通常是代码中保留引用的全局变量，在js中，我们一般认定全局对象window作为root，也就是所谓的根部。
- 从根部出发检查所有 的roots，所有的children也会被递归检查，能从root到达的都会被标记为active。
- 未被标记为active的数据被认定为不再需要，垃圾回收器开始释放它们。

（2）引用计数

**工作原理**：跟踪记录每个值被引用的次数



##### 40. apply/call/bind函数相关方法

**1. apply/call/bind**

改变 this 指针，也可以理解为对象借用方法，就现像生活中向邻居借东西一样的事情。

1）apply

`apply`接受两个参数，第一个参数是`this`的指向，第二个参数是函数接受的参数，以数组的形式传入；立即执行

```js
function fn(...args){
    console.log(this,args);
}
let obj = {
    myname:"张三"
}

fn.apply(obj,[1,2]); // this会变成传入的obj，传入的参数必须是一个数组；
fn(1,2) // this指向window


// 当第一个参数为null、undefined的时候，默认指向window(在浏览器中)
fn.apply(null,[1,2]); // this指向window
fn.apply(undefined,[1,2]); // this指向window
```

2）call

`call`方法的第一个参数也是`this`的指向，后面传入的是一个参数列表（分开传参）；立即执行

```js
function fn(...args){
    console.log(this,args);
}
let obj = {
    myname:"张三"
}

fn.call(obj,1,2); // this会变成传入的obj，传入的参数必须是分开的；
fn(1,2) // this指向window
```

3）bind

bind方法和call很相似，第一参数也是`this`的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入)；不立即执行

```js
function fn(...args){
    console.log(this,args);
}
let obj = {
    myname:"张三"
}

const bindFn = fn.bind(obj); // this 也会变成传入的obj ，bind不是立即执行需要执行一次
bindFn(1,2) // this指向obj
fn(1,2) // this指向window
```

**三者区别：**

- 三者都可以改变函数的`this`对象指向
- 三者第一个参数都是`this`要指向的对象，如果如果没有这个参数或参数为`undefined`或`null`，则默认指向全局`window`
- 三者都可以传参，但是`apply`是数组，而`call`是参数列表，且`apply`和`call`是一次性传入参数，而`bind`可以分为多次传入
- `bind`是返回绑定this之后的函数，`apply`、`call` 则是立即执行



## Vue

> vue2.0中有一个特点，对一个数据的操作是分散在各个对象中的。
> 
> Vue3.0组合API（一些方法），把对一个数据的操作全部组合在一起，代码可读性更高。
> 
> Vue3.0中利用了new Proxy() 代理对象来管理数据响应式(Vue3.0的一个双向数据绑定原理)

##### 1.$set和$delete

通过这两个方法对`Object.defineProperty`进行数组的数据劫持

```js
this.$set(要修改的数组，要修改的下标，要修改成的值)

this.$delete(要删除的数组,*要删除的下标*);
```

##### 2.Vuex

```js
const store = new Vuex.Store({
    /*
       获取store中state的数据：
       (1)this.$store.state.products
       (2){{ $store.state.products }}
    */
  state:{//相当于data
    products: [
      {name: '鼠标', price: 20},
      {name: '键盘', price: 40}
    ]
  },

    /*
       获取getters中的数据：
       (1)this.$store.getters.aa 
       (2){{ $store.getters.aa }}
    */
  getters:{//相当于计算属性computed
    aa: (state) => {
      let bb = state.products.map( product => {
        return {
          name: product.name,
          price: product.price / 2
        }
      })
      return bb;
    }
  },

   /*
       注意:调用mutaions中回调函数, 只能使用store.commit(type, payload)
       例如：this.$store.commit('minusPrice', 2); //提交`minusPrice,payload为2
   */
  mutations:{//相当于methods,用来修改state，绝不允许出现异步
    minusPrice (state, payload ) {
      let newPrice = state.products.forEach( product => {
        product.price -= payload
      })
    }
  },

    /*
       传值：
       this.$store.dispatch('minusPriceAsync', 5); //分发actions中的minusPriceAsync这个异步函数
    */
  actions:{ //相当于mutations，但允许有异步
    minusPriceAsync( context, payload ) {
      setTimeout( () => {
        context.commit( 'minusPrice', payload ); //context提交
      }, 2000)
    }
  }，

    /*
        操作：
        store.state.a // -> moduleA 的状态
        store.state.b // -> moduleB 的状态
    */
   modules: {//模块化
     a: moduleA,
     b: moduleB
   }

})
```

```js
const moduleA = {
  state: { ... },
  mutations: { ... },
  actions: { ... },
  getters: { ... }
}

const moduleB = {
  state: { ... },
  mutations: { ... },
  actions: { ... }
}
```

##### 3.修饰符

(1) `.native`

组件事件的监听，比如说要监听一个组件，必须加上这个修饰符(Vue2.0)。Vue3好像不需要这个了。

```js
<组件 @click.native="btnClick"></组件>

new Vue({
    methods:{
        btnClick(){
            console.log("组件监听");
        }
    }
})
```

##### 4.父子组件生命周期顺序

> 父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted

##### 5.父子组件更新时的生命周期顺序

> 父beforeUpdate->子beforeUpdate->子updated->父updated

##### 6.跨域问题解决

Vue3.0中新建一个vue.config.js文件，然后输入以下代码：

```js
module.exports = {
    devServer: {
        proxy: {
            //跨域代理
            '/api': {
                //target:"代理服务器的目标地址"
                target: 'https://pvp.qq.com/',
                //是否允许跨域
                changeOrigin: true,
                ws: true,
                //路径重写
                pathRewrite: {
                    "^/api": ""
                }
            }
        }
    }
}

//随便一个vue文件下发送axios请求
axios({
    // 默认为get请求
    url: '/api/web201605/js/herolist.json',
  })
  .then((res) => {
    console.log(res);
  })
  .catch((err) => {
    console.log(err);
  });
```

##### 7. Vue 中的声明式渲染是什么？

1）界面能根据**初始数据做初始渲染**显示， 不需要手动操作DOM来显示;
2）要更新界面，只需要更新数据即可， **不用手动操作DOM来更新界面**。



##### 8. MVC和MVVM的区别

**MVC**

<img src="C:%5CUsers%5C20837%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230219161023616.png" alt="image-20230219161023616" style="zoom:80%;" />

**1). Model（模型）**是应用程序中用于处理应用程序**数据逻辑**的部分。
　　通常模型对象负责在数据库中存取数据。

**2). View（视图）**是应用程序中**处理数据显示**的部分。
　　通常视图是依据模型数据创建的。

**3). Controller（控制器）**是应用程序中**处理用户交互**的部分。
　　通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。

最典型的`MVC`就是`JSP + serverlet + javabean`的模式

**MVVM**

![image-20230219160507389](C:%5CUsers%5C20837%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230219160507389.png)

**1). M**： Model模型, 也就是**包含数据的`js`对象**(只包含属性, 不包含方法)

**2). V**： View视图，动态显示模型对象中的**数据显示界面**

**3). VM**： `ViewModel`**视图模型**, 本质是一个`vm`, 通过`vm`读取model中的数据显示到view上, 同时view输入数据改变, `vm`也可以将输入数据保存到model中

**MVVM的优势**: 不用亲自操作DOM, 数据是响应式的, 一旦数据变化, 自动更新界面



##### 9.怎样理解 Vue 的单向数据流？

1. 所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：**父级 prop 的更新会向下流动到子组件中，但是反过来则不行**。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。

2. 每次父级组件发生更新时，子组件中所有的 prop 都将会更新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。**子组件想修改时，可以通过 $emit 派发一个自定义事件**，父组件接收到后，由父组件修改。



##### 10. computed 和 watch 的区别和运用的场景？

1. **computed**： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；

2. **watch**： 更多的是「观察/监视」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；



##### 11. 谈谈你对 Vue 生命周期的理解？

Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -> 渲染、更新 -> 重新渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。

| **生命周期**    | **描述**                                                     |
| --------------- | ------------------------------------------------------------ |
| `beforeCreate`  | 组件实例被创建之初，组件的属性生效之前                       |
| `created`       | 组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用 |
| `beforeMount`   | 在挂载开始之前被调用：相关的 render 函数首次被调用, 但页面还没有挂载显示, $ref还不可用 |
| `mounted`       | 已挂载, 也就是已经显示到界面上了, 此时可能通过$ref访问到页面元素或组件对象 |
| `beforeUpdate`  | 组件数据更新之后, 界面更新之前调用, 如果此时获取的界面是旧的界面 |
| `updated`       | 界面更新之后调用, 如果此时获取界面主是新的界面了             |
| `activited`     | keep-alive 专属，组件激活时调用                              |
| `deactivated`   | keep-alive 专属，组件失活时调用                              |
| `beforeDestory` | 组件销毁前调用, 一般在此做一些收尾的工作, 如: 取消定时器, 解绑监听 |
| `destoryed`     | 组件销毁后调用                                               |



##### 12. Vue 的父组件和子组件生命周期钩子函数执行顺序？

Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：

**1. 加载渲染过程**

父 `beforeCreate` –> 父 `created` –> 父` beforeMount` –> 子 `beforeCreate`

–> 子` created` –> 子 `beforeMount` –> 子 `mounted` –> 父` mounted`

**2. 子组件更新过程**

父 `beforeUpdate` –> 子` beforeUpdate` –> 子 `updated `–> 父 `updated`

**3. 父组件更新过程**

父 `beforeUpdate` –> 父 `updated`

**4. 销毁过程**

父 `beforeDestroy` –> 子 `beforeDestroy` –> 子 `destroyed` –> 父 `destroyed`



##### 13.谈谈你对 keep-alive 的了解

keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：

1. 一般结合路由一起使用，用于缓存路由组件；

2. 提供 include 和 exclude 属性，两者都支持字符串和正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；

3. 对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件离开时，触发钩子函数 deactivated。



##### 14.组件中 data 为什么是一个函数

当 `data` 的值是一个对象时，它会在这个组件的所有实例之间共享

1. 如果组件中的data选项是对象，那这个组件的每个实例都是通过配置的**data属性**得到的， 因此**组件的多个标签实例data共用一个data数据对象**, 一旦有一个组件对象改变了data中的数据， 其它组件对象界面也会更新

2. 如果组件中 data 选项是一个函数，那每个组件对象都是通过执行配置的**data函数**得到的data数据对象， 因此**组件的多个组件对象的data都不是同一个对象**，一个组件对象修改其data内数据， 其它组件对象不会更新，因为data中的数据没有变化。



##### 15. v-model 的原理

**1. v-model用在html标签上：**

1). text 和 textarea 类型 input 标签 使用 value 属性和 input 事件；

2). checkbox 和 radio 类型 input标签 使用 checked 属性和 change 事件；

3). select 标签使用 value 属性和 input 事件。

以 input 表单元素为例：

```js
<input v-model='something'>
```

相当于

```js
<input v-bind:value="something" v-on:input="something = $event.target.value">
```

**2. v-model用在组件标签上: 则会传入 value 属性 和绑定 input 事件监听**

父组件：

```js
<ModelChild v-model="message"></ModelChild>
<!-- 等价于 -->
<ModelChild :value="message" @input="message=$event"></ModelChild>

data () {
  return {
    message: 'Hello atguigu'
  }
}
```

子组件：

```js
<div>
  <input type="text" :value="value" @input="$emit('input', $event.target.value)">
</div>

props: ['value']
```



##### 16. Vue 组件间通信有哪几种方式

**1. 方式一: props**

1). 实现父向子通信: 属性值是非函数
2). 实现子向父通信: 属性值是函数

**2. 方式二: vue自定义事件**

1). 用来实现子组件向父组件通信

2). 相关语法:

● 父组件中绑定自定义事件监听: 

```js
<Child @eventName="callback">
```

● 子组件中分发事件 

```js
this.$emit('eventName', data)
```

3.**方式三: v-model**

1). 实现父子之间相互通信

2). 组件标签上的v-model的本质

● 父组件: 

```js
<CustomInput v-model="name"/>
<!-- 等价于 -->
<CustomInput :value="name" @input="name=$event"/>
```

● 子组件: 

```js
<input type="text" :value="value" @input="$emit('input', $event.target.value)">

props: ['value']
```

**4.  $attrs与$listeners**

1). $attrs

● 实现当前组件的父组件向当前组件的子组件通信

● 它是包含所有父组件传入的标签属性(排除props声明, class与style的属性)的对象

● 使用: 通过 v-bind=”$attrs” 将父组件传入的n个属性数据传递给当前组件的子组件

2). $listeners

● 实现当前组件的子组件向当前组件的父组件通信

● $listeners是包含所有父组件传入的自定义事件监听名与对应回调函数的对象

● 使用: 通过v-on=”$listeners” 将父组件绑定给当前组件的事件监听绑定给当前组件的子组件

**5. $refs, $children, $parent**

1). $refs

● 实现父组件向指定子组件通信

● $refs是包含所有有ref属性的标签对象或组件对象的容器对象

● 使用: 通过 this.$refs.child 得到子组件对象, 从而可以直接更新其数据或调用其方法更新数据

2). $children

● 实现父组件向多个子组件通信

● $children是所有直接子组件对象的数组

● 使用: 通过this.$children 遍历子组件对象, 从而可以更新多个子组件的数据

3). $parent

● 实现子组件向父组件通信

● $parent是当前组件的父组件对象

● 使用: 通过this.$parent 得到父组件对象, 从而可以更新父组件的数据

**6. Vuex**

1). 实现任意组件间通信

2). Vuex 是一个专为 Vue 应用程序设计的管理多组件共享状态数据的 Vue 插件

● 任意组件都可以读取到Vuex中store的state对象中的数据

● 任意组件都可以通过dispatch()或commit()来触发store去更新state中的数据

● 一旦state中的数据发生变化, 依赖于这些数据的组件就会自动更新

**7. 全局事件总线**

1). 实现任意组件间通信

2). 编码:

● 将入口`js`中的`vm`作为全局事件总线对象:   

```js
beforeCreate() {
    Vue.prototype.$bus = this
}
```

● 分发事件/传递数据的组件: 

```js
this.$bus.$emit('eventName', data)
```

● 处理事件/接收数据的组件: 

```js
this.$bus.$on('eventName', (data) => {})
```

 **8.  `.sync`**

1). 实现父子之间相互通信

2). 组件标签的属性上使用.sync的本质

● 父组件:

```js
<child :money.sync="total"/>
<!-- 等价于 -->
<Child :money="total" @update:money="total=$event"/>

data () {
  return {
    total: 1000
  }
}
```

● 子组件:

```js
<button @click="$emit('update:money', money-100)">花钱</button>

props: ['money']
```



##### 17.说说 SSR 的优缺点？

**1. 服务端渲染的优点：**

1). **更好的 SEO**： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；

2). **更快的内容到达时间（首屏加载更快）**： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；

**2. 服务端渲染的缺点：**

1). **更多的开发条件限制**： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；

2). **更多的服务器负载**：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive – CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。



##### 18. `vue`的`diff`算法

**是什么：**

`diff` 算法是一种通过同层的树节点进行比较的高效算法

其有两个特点：

- 比较只会在同层级进行, 不会跨层级比较
- 在`diff`比较的过程中，循环从两边向中间比较



##### 19.`Proxy` 与 `Object.defineProperty` 优劣对比

**1. Proxy 的优势如下:**

1). Proxy 可以**直接监听对象**而非属性；

2). Proxy 可以**直接监听数组**的变化；

3). Proxy 有多达**13 种拦截方法**,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；

4). Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；

5). Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；

**2. Object.defineProperty 的优势如下:**

兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。



##### 20.简述虚拟 DOM 实现原理

虚拟 DOM 的简单实现原理主要包括以下 3 部分：

1. 用` JavaScript 对象`模拟真实 DOM 树，对真实 DOM 进行抽象；

2. `diff `算法  比较`两棵虚拟 DOM 树`的差异；

3. `pach` 算法 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。



##### 21. `vue-router` 路由钩子

路由钩子函数有三种：

- 全局钩子： `beforeEach`(全局前置守卫)、 `afterEach`(全局后置钩子)
- 路由独享的守卫(单个路由里面的钩子)： `beforeEnter`
- 组件路由：`beforeRouteEnter`、 `beforeRouteUpdate`、 `beforeRouteLeave`



##### 22. Vue2响应式原理（如何实现数据绑定的）

Vue 主要通过以下 4 个步骤来实现数据绑定的：

1. **实现一个监听器 `Observer`**：对数据对象进行遍历，包括子属性对象的属性，利用 `Object.defineProperty() `对属性都加上` setter `和 `getter`。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。

2. **实现一个解析器 `Compile`**：解析 `Vue `模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。

3. **实现一个订阅者 `Watcher`**：`Watcher `订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。

4. **实现一个发布者 `Dep`**：订阅器（发布者）采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对**监听器 `Observer`** 和 **订阅者` Watcher `**进行统一管理。

   


##### 23.`Vue3`的响应式原理

1.`Proxy`代理对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。也就是拦截对象中任意属性的变化，包括：属性值的读写、属性的添加、属性的删除等。**直接监听对象而非属性。**

2.`Reflect`反射，对源对象的属性进行操作

**通过`Proxy`（代理）：** 拦截对象中任意属性的变化，包括：属性值的读写，属性的增加，属性的删除等。

**通过`Reffect`（反射）：** 一个通常**以函数作为属性的对象**，对源对象的属性进行操作



##### 23. `vue2`和`vue3`的区别

**1)双向数据绑定原理不同**

**vue2**：vue2的双向数据绑定是利用**ES5的一个API。Object.defineProperty()** 对数据进行劫持，结合发布订阅模式的方式来实现的。

**vue3**：vue3中使用了**ES6的Proxy API**对数据代理。相比vue2.x，使用proxy的优势如下：

- defineProperty只能监听某个属性，不能对全对象监听

- 可以省去for in，闭包等内容来提升效率(直接绑定整个对象即可)

- 可以监听数组，不用再去单独的对数组做特异性操作vue3.x可以检测到数组内部数据的变化。

  

**2)`API`类型不同**

**vue2**：vue2使用**选项类型api**，选项型api在代码里分割了不同的属性：data,computed,methods等。

**vue3**：`vue3`使用**组合式`api`**，新的组合式`api`能让我们使用方法来分割，相比于旧的`api`使用属性来分组，这样代码会更加简便和整洁。



**3)定义数据变量和方法不同**

**vue2**：vue2是把数据放入data中，在vue2中定义数据变量是**data(){}**，创建的方法要在**methods:{}**中。

**vue3**：，vue3就需要使用一个新的setup()方法，此方法在组件初始化构造的时候触发。使用以下三个步骤来建立反应性数据： 

- 从vue引入**reactive**；
- 使用**reactive()** 方法来声明数据为响应性数据；
- 使用setup()方法来返回我们的响应性数据，从而**template**可以获取这些响应性数据。



**4）生命周期钩子函数不同**

`**vue2`中的生命周期**：

- beforeCreate 组件创建之前
- created 组件创建之后
- beforeMount 组价挂载到页面之前执行
- mounted 组件挂载到页面之后执行
- beforeUpdate 组件更新之前
- updated 组件更新之后

**`vue3`中的生命周期**：

- `setup` 开始创建组件
- `onBeforeMount` 组价挂载到页面之前执行
- `onMounted `组件挂载到页面之后执行
- `onBeforeUpdate `组件更新之前
- `onUpdated` 组件更新之后

而且vue3.x 生命周期在调用前需要先进行引入。除了这些钩子函数外，vue3.x还增加了`onRenderTracked` 和`onRenderTriggered`函数。



##### 24.`vue`与`react`的区别

**1. 相同点：**

1). React采用特殊的JSX语法，Vue在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用。

2). 内部都使用虚拟DOM与DOM Diff算法来提升效率

3). 中心思想相同：一切都是组件，组件实例之间可以嵌套。

4). 都提供合理的钩子函数，可以让开发者定制化地去处理需求。

5). 都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载。

6). 在组件开发中都支持mixins的特性。

**2. 不同点：**

1). React: 基于`JSX`编码, 单向数据绑定, 不能直接更新状态数据必须`setState()`指定新数据

2). `Vue`: 基于模板语法, 双向数据绑定, 直接更新data数据





##### 25.`npm run dev`的执行过程

在`npm run dev`的时候，首先会去项目的`package.json`文件里找`scripts `里找对应的` dev `，然后执行 `dev `的命令。

例如启动`vue`项目 `npm run serve`的时候，实际上就是执行了`vue-cli-service serve` 这条命令。





## HTTP

##### 1.三次握手

指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。

![image-20230217232916806](C:%5CUsers%5C20837%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230217232916806.png)

图中字符的含义：

- `SYN`：连接请求/接收 报文段
- `seq`：发送的第一个字节的序号
- `ACK`：确认报文段
- `ack`：确认号。希望收到的下一个数据的第一个字节的序号

**刚开始客户端处于 `Closed` 的状态，而服务端处于 `Listen` 状态**：

> `CLOSED `：没有任何连接状态
>
> `LISTEN `：侦听来自远方 TCP 端口的连接请求

**1）第一次握手**：客户端向服务端发送一个 SYN 报文（SYN = 1），并指明客户端的初始化序列号 ISN(x)，即图中的 seq = x，表示本报文段所发送的数据的第一个字节的序号。此时客户端处于 `SYN_Send` 状态。

> `SYN-SENT` ：在发送连接请求后等待匹配的连接请求

**2）第二次握手**：服务器收到客户端的 SYN 报文之后，会发送 SYN 报文作为应答（SYN = 1），并且指定自己的初始化序列号 ISN(y)，即图中的 seq = y。同时会把客户端的 ISN + 1 作为确认号 ack 的值，表示已经收到了客户端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 x + 1，此时服务器处于 `SYN_REVD` 的状态。

> `SYN-RECEIVED`：在收到和发送一个连接请求后等待对连接请求的确认

**3）第三次握手**：客户端收到服务器端响应的 SYN 报文之后，会发送一个 ACK 报文，也是一样把服务器的 ISN + 1 作为 ack 的值，表示已经收到了服务端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 y + 1，并指明此时客户端的序列号 seq = x + 1（初始为 seq = x，所以第二个报文段要 +1），此时客户端处于 `Establised` 状态。

服务器收到 ACK 报文之后，也处于 `Establised 状态`，至此，双方建立起了 TCP 连接。

> `ESTABLISHED`：代表一个打开的连接，数据可以传送给用户



##### 2.为什么要三次握手，两次不行吗？

最主要的目的就是**双方确认自己与对方的发送与接收是正常的**

只有经过三次握手才能确认双发的收发功能都正常，缺一不可：

- 第一次握手（客户端发送 SYN 报文给服务器，服务器接收该报文）：

  客户端：什么都不能确认；

  服务器确认了：对方发送正常，自己接收正常

- 第二次握手（服务器响应 SYN 报文给客户端，客户端接收该报文）：

  客户端确认了：自己发送、接收正常，对方发送、接收正常；

  服务器确认了：对方发送正常，自己接收正常

- 第三次握手（客户端发送 ACK 报文给服务器）：

  客户端确认了：自己发送、接收正常，对方发送、接收正常；

  服务器确认了：自己发送、接收正常，对方发送、接收正常



##### 3.ISN (Initial Sequence Number) 是固定的吗

**三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据**。

当一端为建立连接而发送它的 SYN 时，它会为连接选择一个初始序号。ISN 随时间而变化，因此每个连接都将具有不同的 ISN。**如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的**。



##### 4.三次握手过程中可以携带数据吗

第三次握手的时候，是可以携带数据的。但是，**第一次、第二次握手绝对不可以携带数据**

假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，然后疯狂重复发 SYN 报文的话（因为攻击者根本就不用管服务器的接收、发送能力是否正常，它就是要攻击你），这会让服务器花费很多时间、内存空间来接收这些报文。



##### 5.什么是半连接队列

服务器第一次收到客户端的 SYN 之后，就会处于 `SYN_RCVD` 状态，此时双方还没有完全建立其连接，服务器会把这种状态下的请求连接放在一个队列里，我们把这种队列称之为**半连接队列**。

当然还有一个**全连接队列**，完成三次握手后建立起的连接就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。



##### 6.如果第三次握手丢失了，客户端服务端会如何处理

服务器发送完 SYN-ACK 包，如果未收到客户端响应的确认包，也即第三次握手丢失。那么服务器就会进行**首次重传**，若等待一段时间仍未收到客户确认包，就**进行第二次重传**。如果重传次数超过系统规定的最大重传次数，则系统将该连接信息从半连接队列中删除。

注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…



##### 7.SYN攻击是什么？

**服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的**，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。

常见的防御 SYN 攻击的方法有如下几种：

- 缩短超时（SYN Timeout）时间
- 增加最大半连接数
- 过滤网关防护
- SYN cookies技术



##### 8.TCP 四次挥手

建立一个 TCP 连接需要三次握手，而终止一个 TCP 连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这是由于 TCP 的**半关闭**（half-close）特性造成的，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

TCP 连接的释放需要发送四个包（执行四个步骤），因此称为四次挥手(`Four-way handshake`)，**客户端或服务端均可主动发起挥手动作**。

![image-20230218001703339](C:%5CUsers%5C20837%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230218001703339.png)

回顾一下上图中符号的意思：

- `FIN` ：连接终止位
- `seq`：发送的第一个字节的序号
- `ACK`：确认报文段
- `ack`：确认号。希望收到的下一个数据的第一个字节的序号

**假设是客户端先发起关闭请求，四次挥手的过程如下：**

简洁版：

1. 客户端发送 FIN 报文给服务端

2. 服务端收到后发送 ACK 报文给客户端

3. 服务端发送 FIN 报文给客户端

4. 客户端收到后，发送 ACK  给服务端，服务端关闭，客户端等待 2MSL 后关闭

详细版：

**1）第一次挥手**：客户端发送一个 FIN 报文（请求连接终止：FIN = 1），报文中会指定一个序列号 seq = u。并**停止再发送数据，主动关闭 TCP 连接**。此时客户端处于 `FIN_WAIT1` 状态，等待服务端的确认。

> `FIN-WAIT-1` - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；

**2）第二次挥手**：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 `CLOSE_WAIT` 状态。

> `CLOSE-WAIT` - 等待从本地用户发来的连接中断请求；

**此时的 TCP 处于半关闭状态，客户端到服务端的连接释放**。客户端收到服务端的确认后，进入`FIN_WAIT2`（终止等待 2）状态，等待服务端发出的连接释放报文段。

> `FIN-WAIT-2` - 从远程TCP等待连接中断请求；

**3）第三次挥手**：如果服务端也想断开连接了（没有要向客户端发出的数据），和客户端的第一次挥手一样，发送 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态，等待客户端的确认。

> `LAST-ACK` - 等待原来发向远程TCP的连接中断请求的确认；

**4）第四次挥手**：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答（ack = w+1），且把服务端的序列值 +1 作为自己 ACK 报文的序号值（seq=u+1），此时客户端处于 **`TIME_WAIT` （时间等待）状态**。

> `TIME-WAIT` - 等待足够的时间以确保远程TCP接收到连接中断请求的确认；

🚨 注意 ！！！这个时候由服务端到客户端的 TCP 连接并未释放掉，**需要经过时间等待计时器设置的时间 2MSL（一个报文的来回时间） 后才会进入 `CLOSED` 状态**（这样做的目的是确保服务端收到自己的 ACK 报文。如果服务端在规定时间内没有收到客户端发来的 ACK 报文的话，服务端会重新发送 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文给服务端）。服务端收到 ACK 报文之后，就关闭连接了，处于 `CLOSED` 状态。



##### 9.为什么要四次挥手

由于 TCP 的**半关闭**（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入**半关闭状态**。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就**完全关闭**了TCP连接。

**通俗的来说，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手**。

举个例子：A 和 B 打电话，通话即将结束后，A 说 “我没啥要说的了”，B 回答 “我知道了”，于是 A 向 B 的连接释放了。但是 B 可能还会有要说的话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，于是 B 向 A 的连接释放了，这样整个通话就结束了。



##### 10.四次挥手释放连接时，等待2MSL（最长报文段寿命）的意义?

1. **保证客户端发送的最后一个ACK报文段能够到达服务端**。 这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。

2. **防止“已失效的连接请求报文段”出现在本连接中**。 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。

##### 11. 为什么握手只要三次，挥手却要四次？

关键就在中间两步。

- 建立连接时，当服务器收到客户端的`SYN 报文`后，可以直接发送`SYNACK 报文`。其中`ACK`是用来应答的，`SYN`是用来同步的。
- 但是关闭连接时，当服务器收到`FIN 报文`时，很可能并不会立即关闭`SOCKET`，所以只能先回复一个`ACK 报文`，告诉客户端，“你发的`FIN 报文`我收到了”。只有等到服务器所有的报文都发送/接收完了，我才能发送`FIN 报文`，因此不能一起发送，需要四次握手。

##### 12.说一说你对 DNS 的理解？

**DNS (Domain Name System)** 是互联网中的重要基础设施，负责对域名的解析工作，为了保证高可用、高并发和分布式，它设计成了树状的层次结构。

1. 由**根DNS服务器**、**顶级域 DNS 服务器**和**权威 DNS 服务器**组成。

2. 解析顺序是首先从**浏览器缓存**、**操作系统缓存**以及**本地 DNS 缓存 (/etc/hosts)** 逐级查找，然后从**本地 DNS 服务器**、**根 DNS**、**顶级 DNS** 以及**权威 DNS**层层递归查询。

3. 可以基于域名在内网、外网进行负载均衡。

4. 传统的 DNS 有很多问题(解析慢、更新不及时)，**HTTPDNS** 通过客户端 SDK 和服务端配合，直接通过 HTTP 调用解析 DNS 的方式，可以绕过传统 DNS 这些缺点，实现智能调度

##### 13.说一说你对 CDN 的理解？

**CDN（Content Delivery Network）**就是内容分发网络。

1. 为了突破现实生活中的光速、传输距离等物理限制，CDN 投入了大量资金，在全球范围内各大枢纽城市建立机房，部署大量高存储高带宽的节点，构建跨运营商、跨地域的专用高速传输网络。

2. DNS 分为中心节点、区域节点、边缘节点等，在用户接入网络后，首先通过全局负载均衡 **(Global Sever Load Balance)**，简称 GSLB 算法负责调度，找到离用户最合适的节点。然后通过 HTTP 缓存代理技术进行缓存，缓存命中就返回给用户，否则就回源站去取。**CDN 擅长缓存静态资源(图片、音频等)**，当然也支持动态内容的缓存。



## AJAX

##### 1.什么是AJAX

1. AJAX 是 『Asynchronous JavaScript and XML』的缩写。它是指一种创建交互式网页应用的网页开发技术。

2. 客户端与服务器，可以在**不刷新整个浏览器**的情况下，与服务器进行异步通讯的技术



##### 2.原生 AJAX 请求处理

| 方法/属性              | 描述                                                         |
| ---------------------- | ------------------------------------------------------------ |
| open(method,url,async) | 规定请求的类型、URL 以及是否异步处理请求。<br/>**method**：请求的类型；GET 或 POST<br/>**url**：文件在服务器上的位置<br/>**async**：true（异步）或 false（同步） |
| send(string)           | 将请求发送到服务器。string：仅用于 POST 请求                 |
| status                 | 200: "OK"                                                    |
| responseText           | 获得字符串形式的响应数据。                                   |
| responseXML            | 获得 XML 形式的响应数据。                                    |
| readyState             | 存有 XMLHttpRequest 的状态。请求发送到后台后，状态会从 0 到 4 发生变化。 <br/> **0**: 请求未初始化   <br/>**1**: 服务器连接已建立   <br/>**2**: 请求已接收   <br/>**3**: 请求处理中   <br/>**4**: 请求已完成，且响应已就绪 |
| onreadystatechange     | 每当 readyState 属性改变时，就会调用该函数。                 |

```js
// get请求
// 1.创建对象
var xhr = new XMLHttpRequest();
// 2.连接服务器，设置（请求参数，请求地址，同步还是异步）
xhr.open('GET', '/api/user?id=333', true);
// 3.发送请求
xhr.send();
// 4.监听事件，获取返回的数据
xhr.onreadystatechange = function (e) {
  if (xhr.readyState == 4 && xhr.status == 200) {
    console.log(xhr.responseText);
  }
};
```

```js
// post请求
// 1.创建对象
var xhr = new XMLHttpRequest();
// 2.连接服务器，设置（请求参数，请求地址，同步还是异步）
xhr.open('POST', '/api/user', true);
// 3.POST请求需要设置此参数（设置请求头）
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded')
// 4.发送请求
xhr.send('name=33&ks=334');
// 5.监听事件，获取返回的数据
xhr.onreadystatechange = function (e) {
  if (xhr.readyState == 4 && xhr.status == 200) {
    console.log(xhr.responseText);
  }
};
```



##### 3.请解释一下 JavaScript 的同源策略

同源策略指的是：协议，域名，端口相同，**同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性**。



##### 4. 如何解决跨域问题

**1. 跨域的概念：**

协议、域名、端口都相同才同域，否则都是跨域

**2. 解决跨域问题：**

1). 使用JSONP（json+padding）把数据内填充起来
2). CORS 方式（跨域资源共享），在后端上配置可跨域
3). 服务器代理，通过服务器的文件能访问第三方资源（比如nginx）



## 浏览器缓存于渲染机制

##### 1.介绍一下浏览器（http）缓存位置和优先级

1. **Service Worker**

   和`WebWorker`类似，是独立的线程，我们可以在这个线程中缓存文件，在主线程需要的时候读取这里的文件，Service Worker使我们可以自由选择缓存哪些文件以及文件的匹配、读取规则，并且缓存是持续性的

2. **Memory Cache（内存缓存）**

   即内存缓存，内存缓存不是持续性的，缓存会随着进程释放而释放

3. **Disk Cache（硬盘缓存）**

   硬盘缓存的持续性和容量更优，它会根据HTTP header的字段判断哪些资源需要缓存

4. **Push Cache（推送缓存）**

   是HTTP/2的内容，目前应用较少

5. 以上缓存都没命中就会进行网络请求



##### 2.介绍一下浏览器缓存策略

**1. 强缓存(不要向服务器询问的缓存)**

**1). 设置Expires**

即过期时间，例如「Expires: Thu, 26 Dec 2019 10:30:42 GMT」表示缓存会在这个时间后失效，这个过期日期是绝对日期，如果修改了本地日期，或者本地日期与服务器日期不一致，那么将导致缓存过期时间错误。

**2). 设置Cache-Control**

HTTP/1.1新增字段，Cache-Control可以通过max-age字段来设置过期时间，例如「Cache-Control:max-age=3600」除此之外Cache-Control还能设置private/no-cache等多种字段

**2. 协商缓存(需要向服务器询问缓存是否已经过期)**

**1). Last-Modified**

即最后修改时间，浏览器第一次请求资源时，服务器会在响应头上加上Last-Modified ，当浏览器再次请求该资源时，浏览器会在请求头中带上If-Modified-Since 字段，字段的值就是之前服务器返回的最后修改时间，服务器对比这两个时间，若相同则返回304，否则返回新资源，并更新Last-Modified

**2). ETag**

HTTP/1.1新增字段，表示文件唯一标识，只要文件内容改动，ETag就会重新计算。缓存流程和 Last-Modified 一样：服务器发送 ETag 字段 -> 浏览器再次请求时发送 If-None-Match -> 如果ETag值不匹配，说明文件已经改变，返回新资源并更新ETag，若匹配则返回304

**3). 两者对比**

ETag 比 Last-Modified 更准确：如果我们打开文件但并没有修改，Last-Modified 也会改变，并且 Last-Modified 的单位时间为一秒，如果一秒内修改完了文件，那么还是会命中缓存

如果什么缓存策略都没有设置，那么浏览器会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间



##### 3.如何根据浏览器渲染机制加快首屏速度

**1）. 优化文件大小**

`HTML `和 `CSS `的加载和解析都会阻塞渲染树的生成，从而影响首屏展示速度，因此我们可以通过优化文件大小、减少` CSS` 文件层级的方法来加快首屏速度

**2）. 避免资源下载阻塞文档解析**

浏览器解析到 <script> 标签时，会阻塞文档解析，直到脚本执行完成，因此我们通常把 <script> 标签放在底部，或者加上 defer、async 来进行异步下载





